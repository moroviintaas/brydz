use rand::seq::SliceRandom;
use rand::thread_rng;
use smallvec::SmallVec;
use brydz_core::meta::HAND_SIZE;
use brydz_core::amfiteatr::spec::ContractDP;
use brydz_core::amfiteatr::state::ContractAction;
use amfiteatr_core::agent::{Policy, PresentPossibleActions};
use amfiteatr_core::error::AmfiteatrError;

pub struct EEPolicy<IntPolicy: Policy<ContractDP>>{
    start_exploiting: u64,
    exploiting_policy: IntPolicy,
    step_counter: u64,

}

impl<IntPolicy: Policy<ContractDP>> EEPolicy<IntPolicy>{
    pub fn new(policy: IntPolicy) -> Self{
        Self{exploiting_policy: policy, start_exploiting: 0, step_counter: 0}
    }
    pub fn exploiting_policy_mut(&mut self) -> &mut IntPolicy{
        &mut self.exploiting_policy
    }
    pub fn exploitation_start(&self) -> u64{
        self.start_exploiting
    }
    pub fn set_exploiting_start(&mut self, start: u64){
        self.start_exploiting = start
    }
    pub fn exploiting_start(&self) -> u64{
        self.start_exploiting
    }
    pub fn reset_step_counter(&mut self){
        self.step_counter = 0;
    }
    pub fn get_step_counter(&self) -> u64{
        self.step_counter
    }
    pub fn internal_policy(&self) -> &IntPolicy{
        &self.exploiting_policy
    }
    pub fn internal_policy_mut(&mut self) -> &mut IntPolicy{
        &mut self.exploiting_policy
    }
}

impl<IntPolicy: Policy<ContractDP>> Policy<ContractDP> for EEPolicy<IntPolicy>
where <IntPolicy as Policy<ContractDP>>::InfoSetType:  PresentPossibleActions<ContractDP>{
    type InfoSetType = IntPolicy::InfoSetType;

    fn select_action(&self, state: &Self::InfoSetType) -> Result<ContractAction, AmfiteatrError<ContractDP>> {
        //self.step_counter.set(self.step_counter.get() + 1);
        if self.step_counter >= self.start_exploiting{

            self.exploiting_policy.select_action(state)
        } else{
            let mut rng = thread_rng();
            let available_actions: SmallVec<[ContractAction; HAND_SIZE]> = state.available_actions().into_iter().collect();
            let action = available_actions.choose(&mut rng).cloned();
            action.map(|a| a.to_owned()).ok_or(AmfiteatrError::NoActionAvailable {
                context: "EEPolicy".into()
            })
        }


    }

}